<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Flask Demo</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <!-- Custom CSS -->
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <!-- Chart.js for plotting graphs -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <!-- Logo in the top right -->
  <img src="{{ url_for('static', filename='logo.png') }}" alt="Logo" class="logo"
  style="position: absolute; top: 10px; right: 10px; width: 100px; height: auto; cursor: pointer;"
  onclick="window.location.href='https://ixlabs.ie.edu/';">
  
  <h1>Flask Demo</h1>
  <div id="controls">
    <label for="yearSlider">Select Year:</label>
    <input type="range" class="slider" min="{{ min_year }}" max="{{ max_year }}" value="{{ max_year }}" step="1" id="yearSlider">
    <span id="yearLabel">{{ max_year }}</span>
  </div>
  <div id="map"></div>
  <div id="graph-container" style="display: flex; align-items: flex-start; width: 80%; align-self: center; margin: auto auto;">
    <div id="graph" style="flex: 1;"></div>
    <div id="info-popup" style="flex: 0.5;">
      <h3>Statistics</h3>
      <p><strong>Region Name:</strong> <span id="regionName"></span></p>
      <p><strong>Estimated Mortality (Next Years):</strong> <span id="estimatedMortality"></span></p>
      <p><strong>Estimated Change:</strong> <span id="percentageChange"></span>%</p>
    </div>
  </div>
  
  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // Initialize the Leaflet map using backend values for center and zoom.
    const default_zoom = parseInt("{{ zoom }}", 10);
    // Center coordinates for the map, passed from Flask backend.
    const default_center = [parseFloat("{{ center_lat }}"), parseFloat("{{ center_lon }}")];
    // Create the map and set its view to the specified center and zoom level.
    const map = L.map('map').setView(default_center, default_zoom);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);
    let geoJsonLayer = null;
    
    // Function to fetch mortality data for the selected year and update the map.
    function loadDataForYear(region, year) {
      fetch(`/api/mortality?region=${region}&year=${year}`)
        .then(response => response.json())
        .then(data => {
          if (geoJsonLayer) {
            map.removeLayer(geoJsonLayer);
          }
          geoJsonLayer = L.geoJSON(data, {
            style: feature => {
              const deaths = feature.properties.mortality || 0;
              // Calculate intensity based on squared value (adjust as needed for your data)
              let intensity = Math.min(deaths ** 2, 255);
              return {
                fillColor: `rgb(0, ${intensity}, 0)`,
                fillOpacity: 0.7,
                weight: 1,
                color: '#999'
              };
            },
            onEachFeature: (feature, layer) => {
              // If the region name is "Austria", a button will be added to the popup.
              // When clicked, it takes the user to the "austria" subpage.
              if (feature.properties.name === "Austria") {
                layer.bindPopup(`<b>${feature.properties.name}</b><br>Mortality: ${feature.properties.mortality}<br><button onclick="window.location.href='/austria'">Go to Austria</button>`);
              } else {
                layer.bindPopup(`<b>${feature.properties.name}</b><br>Mortality: ${feature.properties.mortality}`);
              }
              // When the user clicks a region, plot its mortality history.
              layer.on('click', () => plotGraph(feature.properties));
            }
          }).addTo(map);
        })
        .catch(error => console.error('Error fetching data:', error));
    }
    
    // Function to update the info popup with region details.
  function updateInfoPopup(properties) {
    const regionName = properties.name;
    const currentMortality = properties[`mortality_{{ max_year }}`] || 0;
    const percentageChange = (Math.random() * 5 + 1).toFixed(2); // Random value between 1 and 10
    const estimatedMortality = (currentMortality * (1 + percentageChange/100)).toFixed(0);
    

    // Update the popup content.
    document.getElementById('regionName').innerText = regionName;
    document.getElementById('estimatedMortality').innerText = estimatedMortality;
    document.getElementById('percentageChange').innerText = percentageChange;

    // Show the popup.
    document.getElementById('info-popup').style.display = 'block';
  }

  // Update the plotGraph function to also update the info popup.
  function plotGraph(properties) {
    const minYear = parseInt("{{ min_year }}", 10);
    const maxYear = parseInt("{{ max_year }}", 10);
    const years = [];
    const deaths = [];
    for (let y = minYear; y <= maxYear; y++) {
      years.push(y);
      deaths.push(properties[`mortality_${y}`] || 0);
    }
    const graphDiv = document.getElementById("graph");
    // Clear any previous graph.
    graphDiv.innerHTML = "";
    // Create a canvas element for Chart.js.
    const canvas = document.createElement("canvas");
    graphDiv.appendChild(canvas);
    const ctx = canvas.getContext("2d");
    new Chart(ctx, {
      type: 'line',
      data: {
        labels: years,
        datasets: [{
          label: `Mortality for ${properties.name} (per thousand)`,
          data: deaths,
          borderColor: '#6dc201',
          backgroundColor: '#6dc2014D', // 30% opacity
          fill: true,
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          y: {
            beginAtZero: true,
            min: 0,
            max: 25,
          }
        }
      }
    });

    // Update the info popup with region details.
    updateInfoPopup(properties);
  }
    
    // Initial load for the default year.
    loadDataForYear("{{ region }}", "{{ max_year }}");
    
    // Update map data when the slider changes.
    // Debounce slider input - wait 300ms after the last input before calling the function.
    // This prevents excessive calls to the function when the user is sliding the slider.
    let debounceTimer;
    document.getElementById('yearSlider').addEventListener('input', function() {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        const selectedYear = this.value;
        document.getElementById('yearLabel').innerText = selectedYear;
        const region = "{{ region }}"; // Define the region variable from the backend
        loadDataForYear(region, selectedYear);
      }, 300); // 300ms debounce delay
    });
  </script>
</body>
<!-- Footer Section -->
<footer>
  <p>Demo done by <a href="http://danielprecioso.com" target="_blank">Daniel Precioso</a> for IE University. 
  This tool is for demonstration purposes only. The data displayed may not represent real-world scenarios.</p>
</footer>
</html>
